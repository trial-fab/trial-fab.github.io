<!doctype html>
<html>
  <head>
    <meta charset="utf-8" />
    <meta name="viewport" content="width=device-width,initial-scale=1" />
    <title>Class Length Tracker</title>
    <style>
      body { font-family: system-ui, -apple-system, Segoe UI, Roboto, sans-serif; max-width: 720px; margin: 24px auto; padding: 0 12px; }
      form, .card { border: 1px solid #ddd; border-radius: 12px; padding: 16px; margin: 12px 0; }
      label { display: block; margin: 8px 0 4px; }
      input { width: 100%; padding: 8px; border: 1px solid #ccc; border-radius: 8px; }
      button { padding: 10px 14px; border: 0; border-radius: 10px; cursor: pointer; }
    </style>
  </head>
  <body>
    <h1>Class Length Tracker</h1>

    <form id="entryForm">
      <label>PowerPoint # <input type="number" name="ppt_number" required></label>
      <label>Slides <input type="number" name="slides" required></label>
      <label>Start time (EST) <input type="datetime-local" name="start_time" required></label>
      <label>End time (EST) <input type="datetime-local" name="end_time" required></label>
      <button type="submit">Add</button>
      <span id="status"></span>
    </form>

    <div class="card">
      <h2>Live Estimate</h2>
      <div id="estimate">Loading…</div>
    </div>

    <div class="card">
      <h2>Recent Entries</h2>
      <table id="table" border="0" cellpadding="6"></table>
    </div>

    <script>
      // ===== configure this =====
      const API = 'https://script.google.com/macros/s/AKfycbzvC2QkZ6CT-vSVpIMp0GfN3JSLC4PwdWZj-DIn6aZlZOAK-7sPuBZGMwWLzW12mSfb/exec';

      // current time in EST
      function nowInEST() {
        // America/New_York handles EST/EDT automatically
        return new Date(new Date().toLocaleString('en-US', { timeZone: 'America/New_York' }));
      }

      // minutes between two local datetime strings
      function minutesBetween(startLocal, endLocal) {
        const s = new Date(startLocal);
        const e = new Date(endLocal);
        return (e - s) / 60000;
      }

      async function fetchData() {
        const res = await fetch(API);
        const json = await res.json();
        return json.data || [];
      }

      function computeStats(rows) {
        // rows: [{ppt_number, slides, start_time, end_time}, ...]
        // compute per-slide rate (minutes per slide) using entries with valid times & slides > 0
        const rates = [];
        let totalSlides = 0;

        rows.forEach(r => {
          const slides = Number(r.slides);
          if (!slides || !r.start_time || !r.end_time) return;
          const mins = minutesBetween(r.start_time, r.end_time);
          if (mins > 0 && slides > 0) {
            rates.push(mins / slides);
            totalSlides += slides;
          }
        });

        const avgRateMinPerSlide = rates.length
          ? rates.reduce((a,b)=>a+b,0) / rates.length
          : null;

        return { avgRateMinPerSlide, totalSlides };
      }

      function renderTable(rows) {
        const table = document.getElementById('table');
        table.innerHTML = '';
        if (!rows.length) { table.innerHTML = '<i>No data yet</i>'; return; }

        const header = document.createElement('tr');
        ['ppt_number','slides','start_time','end_time'].forEach(h => {
          const th = document.createElement('th'); th.textContent = h; header.appendChild(th);
        });
        table.appendChild(header);

        rows.slice(-10).forEach(r => {
          const tr = document.createElement('tr');
          ['ppt_number','slides','start_time','end_time'].forEach(k => {
            const td = document.createElement('td'); td.textContent = r[k] ?? ''; tr.appendChild(td);
          });
          table.appendChild(tr);
        });
      }

      function renderEstimate(rows) {
        const est = document.getElementById('estimate');
        const { avgRateMinPerSlide, totalSlides } = computeStats(rows);
        if (!avgRateMinPerSlide) {
          est.innerHTML = 'Insufficient data to estimate yet.';
          return;
        }

        // Example idea: predict time for *one more deck* once the group inputs its slide count
        // You can adapt this to your exact logic, e.g., get remaining slides from URL param or input.
        const remainingSlidesInputId = 'remainingSlides';
        if (!document.getElementById(remainingSlidesInputId)) {
          const wrap = document.createElement('div');
          wrap.innerHTML = `
            <label>Remaining slides to cover <input id="${remainingSlidesInputId}" type="number" min="0" value="30"></label>
            <button id="calcBtn" type="button">Calculate ETA</button>
            <div id="eta"></div>
          `;
          est.appendChild(wrap);

          document.getElementById('calcBtn').addEventListener('click', () => {
            const rem = Number(document.getElementById(remainingSlidesInputId).value || 0);
            const minsLeft = rem * avgRateMinPerSlide;

            // compute local time in America/New_York
            const nowEST = nowInEST();
            const eta = new Date(nowEST.getTime() + minsLeft*60000);
            const etaStr = eta.toLocaleString('en-US', { timeZone: 'America/New_York' });

            document.getElementById('eta').textContent =
              `Avg rate ≈ ${avgRateMinPerSlide.toFixed(2)} min/slide. ` +
              `Estimated time left: ${minsLeft.toFixed(1)} min. ETA (EST): ${etaStr}`;
          });
        } else {
          // already rendered; nothing to do
        }
      }

      async function refresh() {
        const rows = await fetchData();
        renderTable(rows);
        renderEstimate(rows);
      }

      document.getElementById('entryForm').addEventListener('submit', async (e) => {
        e.preventDefault();
        const fd = new FormData(e.target);
        const payload = Object.fromEntries(fd.entries());
        // send to Apps Script
        const status = document.getElementById('status');
        status.textContent = 'Saving…';
        try {
          const res = await fetch(API, {
            method: 'POST',
            headers: { 'Content-Type': 'application/json' },
            body: JSON.stringify(payload)
          });
          const json = await res.json();
          if (json.ok) {
            status.textContent = 'Saved!';
            e.target.reset();
            refresh();
          } else {
            status.textContent = 'Error saving.';
          }
        } catch {
          status.textContent = 'Network error.';
        }
      });

      refresh();
      // optional: auto-refresh every minute
      setInterval(refresh, 60000);
    </script>
  </body>
</html>
